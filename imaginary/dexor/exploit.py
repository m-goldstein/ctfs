from Crypto.Util.number import long_to_bytes as ltb, bytes_to_long as btl
from codecs import decode,encode
import binascii
password = b'g1v3fl4g'
rounds = 5

tobin = lambda x: bytes("".join(f"{i:08b}" for i in x).encode())
tostr = lambda x: ltb(int(x,2))
xor = lambda x,y: bytes([x[z]^y[z%len(y)] for z in range(len(x))])
shift = lambda s: s[-1:] + s[:-1]
output_bytes = decode(b'bdabad262e769d0406e0bd299850a84f57775854f7811b2235ce800d780683075773','hex')

prefix = b'ictf{'
idx = len(prefix)
prefix += b'\x00'*(len(output_bytes)-len(prefix)-1) + b'}'
flag = list(prefix)
def encryption(flag,password=password):
    for i in range(5):
        s = tostr(shift(tobin(flag)))
        n = xor(s, password)
        flag = xor(flag, n)
    return flag
asciz = [e for e in range(0x20, 0x7f)]
while True:
    for c in asciz:
        tmp_flag = b''.join(chr(e).encode() for e in flag[:idx] + [c]+flag[idx+1:])
        print(f'trying: {tmp_flag}')
        output = encryption(tmp_flag)
        if output[:idx+1] == output_bytes[:idx+1]:
            flag[idx] = c
            idx += 1
            break
        if tmp_flag[:idx].endswith(b'}'):
            print(f'flag: {tmp_flag.decode()}')
            exit(0)
