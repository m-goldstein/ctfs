from pwn import *
from Crypto.Util.number import inverse, GCD
import math
### FROM rabbithole.py ####
p = 95448141706840057074981648919653158061602940212059310641262844843045070085413
g = 2
############################
def _(arg,end='\n'):
    pass
host = '67.159.89.33'
port = 18000
debug = _
done = False
while not done:
    s = [0]*2
    c = [0]*2
    for i in range(2):
        try:
            conn = remote(host,port)
            buf = conn.recvuntil(b't = ')
            t = int(conn.recvuntil(b'\n')[:-1],10)
            debug(f"t: {t}")
            
            ## Seek in buffer to c = 
            debug(conn.recvuntil(b'c = '))
            conn.sendline(b'1') if i == 0 else conn.sendline(b'0')
            debug(conn.recvuntil(b's = '))
            s[i] = int(conn.recvuntil(b'\n')[:-1],10)
            debug(f"s[{i}]: {s[i]}")
            # seek in buffer to t = 
            debug(conn.recvuntil(b't = '))
            conn.sendline(b'1')
            # seek in buffer to c = 
            debug(conn.recvuntil(b'c = '))
            c[i] = int(conn.recvuntil(b'\n')[:-1],10)
            if i == 0:
                conn.sendline(str(0).encode())
                debug(conn.recvuntil(b"!'\n"))
                debug(conn.recvline())
                done = False
            else:
                key = abs(s[1]-s[0])
                debug(f"key: {key}")
                ## need it such that pow(g,s,p) == pow(g,key*c,p) where t = 1 to simplify.
                ## simply let s = key * c_i using relations derived above
                conn.sendline(str(key*c[i]).encode())
                debug(conn.recvuntil(b"wrote '"))
                flag = conn.recvuntil(b"'").decode()[:-1]
                if 'ictf' in flag:
                    print(f'flag: {flag}')
                    done = True
                    break
        except Exception as e:
            print(f"Exception: {e}")
            conn.close()
