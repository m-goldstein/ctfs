"""
Table: User
    username: text
    rsa_key: blob

Table: Parameters:
    id: int
    encrypted_aes_key_for_initiator: blob
    encrypted_aes_key_for_peer: blob
    iv: blob

Table: sqlite_sequence(name,seq)

Table: Conversation
    id: int
    initiator: text
    peer: text
    initial_parameteres: int
    foreign key (initiator) references User(username)
    foreign key (peer) references User(username)
    foreign key (initial_paramteres) references Parameters(id)
    unique(initiator,peer)

Table: Message:
    conversation: int
    timestamp: int
    from_initiator: bool
    next_paramters: bool
    encrypted_msg: blob
    foreign key (conversation) references Conversation(id)
    foreign key (next_parameters) references Parameters(id)
"""
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from codecs import encode,decode
import os
import sys
import json
from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes,bytes_to_long,GCD,inverse,getPrime
import base64 as b64
b64encode = b64.b64encode
b64decode = b64.b64decode
def egcd(a,b):
    s1,s2 = 1,0
    t1,t2 = 0,1
    while b != 0:
        q = a//b
        r = a%b
        a,b= b,r
        s = s1-q*s2
        s1,s2 = s2,s
        t = t1-q*t2
        t1,t2=t2,t
    return (s1,t1)

def pad(s,BLOCK_SIZE=AES.block_size,PADDING=b'\x00'):
    if type(s) != type(b'a'):
        s = decode(s,'hex')
    if len(s) % BLOCK_SIZE:
        return (s + ((BLOCK_SIZE-(len(s)%BLOCK_SIZE))*PADDING))
    else:
        return s
# n -- integer
# k -- kth root
def iroot(n, k):
    u,s = n,n+1
    while u < s:
        s = u
        t = (k-1)*s+n // pow(s,k-1)
        u = t//k
    return s

def parse_sqldata(data,keys=[]):
    try:
        ret = []
        splitted = [e.rstrip() for e in data.split('INSERT INTO "table" VALUES') if len(e)]
        for i in range(len(splitted)):
            e = splitted[i]
            if e.startswith('('):
                e = e[1:]
            if e.endswith(');'):
                e = e[:-2]
            elif e.endswith(';'):
                e = e[:-1]
            splitted[i] = e
        for e in splitted:
            d = {}
            entries = e.split(',')
            for i in range(len(keys)):
                key = keys[i]
                entry = entries[i]
                if entry.startswith("X'") and entry.endswith("'"):
                    entry = entry[2:-1]
                d[key] = entry
            ret.append(d)
        return ret
    except Exception as e:
        print(f"Exception: {e}")

# open the files (extracted using sqlite3)
fconversation_data = open('conversationdata.sql','r')
fmsg_data = open('msgdata.sql','r')
fparam_data = open('paramdata.sql','r')
fuser_data = open('userdata.sql','r')
fsqlite_sequence_data = open('sqlite_sequence_data.sql','r')
wordlist = open('words','r')
words = wordlist.read().split('\n')[:-1]
# read contents into buffers
raw_conversation_data = fconversation_data.read()
raw_msg_data = fmsg_data.read() 
raw_param_data = fparam_data.read() 
raw_user_data = fuser_data.read() 
raw_sqlite_sequence_data = fsqlite_sequence_data.read() 

# make into list of dictionaries
conversation_data = parse_sqldata(raw_conversation_data, keys=['id','initiator','peer','params'])
msg_data = parse_sqldata(raw_msg_data, keys=['conversation','timestamp','from_initiator','next_params','encrypted_msg'])
param_data = parse_sqldata(raw_param_data, keys=['id','aes_key_initiator','aes_key_peer','iv'])
user_data = parse_sqldata(raw_user_data, keys=['username','rsakey'])
sqlite_sequence_data = parse_sqldata(raw_sqlite_sequence_data, keys=['name','seq'])

asciz = [e for e in range(0x20,0x7f)]
keys = [key for key in conversation_data[0].keys()]
for d in conversation_data:
    id = d['id']
    initiator = d['initiator']
    peer = d['peer']
    params = d['params']
    

    # RSA2048-OAEP stuff
    initiator_rsakey = [e['rsakey'] for e in user_data if e['username'] == initiator][0]
    peer_rsakey = [e['rsakey'] for e in user_data if e['username'] == peer][0]
    initiator_rsakey = RSA.import_key(decode(initiator_rsakey,'hex'))
    peer_rsakey = RSA.import_key(decode(peer_rsakey,'hex'))

    peer_rsacipher = PKCS1_OAEP.new(peer_rsakey)
    initiator_rsacipher = PKCS1_OAEP.new(initiator_rsakey)


    conversation_paramdata = [e for e in param_data if e['id'] == params][0]


    # AES256-CBC stuff
    initiator_aeskey = conversation_paramdata['aes_key_initiator']
    peer_aeskey = conversation_paramdata['aes_key_peer']
    conversation_iv = conversation_paramdata['iv']

    conversation_msgdata = [e for e in msg_data if e['conversation'] == id]
    conversation_msgdata = sorted(conversation_msgdata, key=lambda x: x['timestamp'])
    for e in conversation_msgdata:
        use_initiator_key = True if e['from_initiator'] == '1' else False
        iv = decode(conversation_iv,'hex')
        peer_aeskey_b = decode(peer_aeskey,'hex')
        peer_aeskey_l = int(peer_aeskey, 16)
        initiator_aeskey_b = decode(initiator_aeskey, 'hex')
        initiator_aeskey_l = int(initiator_aeskey, 16)
        next_params = [f for f in param_data if f['id'] == e['next_params']][0]
        ciphertext = decode(e['encrypted_msg'], 'hex')

        found_key = False
        while not found_key:
            for w in words: 
                k = (w.encode())
                enc_k = initiator_rsacipher.encrypt(k) if use_initiator_key else peer_rsacipher.encrypt(k)
                #print(k)
                #print(enc_k)
                if use_initiator_key:
                    if enc_k == initiator_aeskey_b:
                        print(f'found initiator AES key: {k} --> {enc_k}')
                        found_key = True
                        input()
                else:
                    if enc_k == peer_aeskey_b:
                        print(f'found peer AES key: {k} --> {enc_k}')
                        found_key = True
                        input()
            print('thats all folks')
            #input()
            break

        #ap1 = iroot(peer_rsa_n,2)
        #ap2 = iroot(initiator_rsa_n,2)

        #initiator_aeskey_dec = long_to_bytes(pow(initiator_aeskey_l, inverse(initiator_rsa_e,ap2),initiator_rsa_n))
        #peer_aeskey_dec = long_to_bytes(pow(peer_aeskey_l, inverse(peer_rsa_e,ap1), peer_rsa_n))
        #initiator_aeskey_dec = long_to_bytes(pow(initiator_aeskey_l, initiator_rsa_e,initiator_rsa_n))
        #peer_aeskey_dec = long_to_bytes(pow(peer_aeskey_l, peer_rsa_e, peer_rsa_n))
        
        #cipher1 = AES.new(pad(initiator_aeskey_dec),AES.MODE_CBC,iv=iv)\
        #        if use_initiator_key else AES.new(pad(peer_aeskey_dec),AES.MODE_CBC,iv=iv)

        #cipher2 = AES.new(pad(initiator_aeskey_dec),AES.MODE_CBC,iv=iv)\
        #        if not use_initiator_key else AES.new(pad(peer_aeskey_dec),AES.MODE_CBC,iv=iv)

        #dec1 = cipher1.decrypt(ciphertext)
        #dec2 = cipher2.decrypt(ciphertext)

        #print(f'use initiator key:  {use_initiator_key}')
        #print(f'dec1: {dec1}')
        #print(f'dec2: {dec2}')
        #input()
        #cipher = AES.new(long_to_bytes(pow(initiator_aeskey_l,initiator_rsakey_l,n)), AES.MODE_CBC,iv=iv)\
        #        if use_initiator_key else AES.new(long_to_bytes(pow(peer_aeskey_l, peer_rsakey_l,n)), AES.MODE_CBC,iv=iv)
        #key = decode(initiator_aeskey,'hex') if use_initiator_key else decode(peer_aeskey,'hex')
        # The AES key was encrypted using RSA2048-OAEP
        # so we need to decrypt that before we can create a cipher


        #rsakey = decode(initiator_rsakey,'hex') if use_initiator_key else decode(peer_rsakey,'hex')
        #rsakey_long = bytes_to_long(rsakey)
        #key_long = bytes_to_long(key)
        #dec_key = pow(key_long, rsakey_long, int(peer_rsakey,16)*int(initiator_rsakey,16))
        #ciphertext_long = bytes_to_long(ciphertext)
        #enc = pow(ciphertext_long, rsakey_long, int(peer_rsakey,16)*int(initiator_rsakey,16)) 
        #break
        #input()
